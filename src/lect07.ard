\import Data.Bool
\import Data.List
\import Logic
\import Meta
\import Paths
\import Paths.Meta

-- 1. Вселенные, полиморфизм по уровням

-- Тип \Type0 содержит все типы, которые не упоминают \Type0
-- Тип \Type1 содержит все типы, которые могут упоминать \Type0, но не \Type1
-- И так далее. Тип \Type n содержит все типы, которые упоминают только \Type i для i < n
-- Тип \Type i называется вселенной, а число i называется уровнем вселенной
\func ttt : \Type2 => \Type0 -> \Type1

\func test : \Type => \Type

\func id (A : \Type) (a : A) => a

-- У каждого определения есть неявный параметр-уровень, к которому можно обратиться, написав \lp
-- Например, функция id, определенная выше, эквивалентна такому определению:
\func id_ (A : \Type \lp) (a : A) => a

-- Когда мы пишем \Type без указания уровня, тайпчекер сам выводит минимальный подходящий уровень
\func type : \Type => \Type

-- Например, в примере выше у \Type, который написан в теле функции, будет выведен уровень \lp
-- У \Type, который написан в типе, уровень \lp не может быть, так как не верно,
-- что \Type \lp : \Type \lp, поэтому он будет на 1 выше, то есть \suc \lp
\func type_ : \Type (\suc \lp) => \Type \lp

-- На уровнях есть небольшой набор операций:
-- * Любое натуральное число является уровнем
-- * \suc l
-- * \max l1 l2
-- То есть любой уровень является либо константой, либо эквивалентен уровню вида \max (\lp + c) c',
-- где c и c' -- константы, а \lp + c -- это уровень вида \suc (\suc ... (\suc \lp) ... )
-- Уровень пи-типов и других конструкций над типами -- это максимум из уровней типов, входящих в эту конструкцию
\func test0 : \Type (\max (\suc (\suc \lp)) 4) => \Type (\max \lp 3) -> \Type (\suc \lp)

-- Когда мы определяем полиморфную функцию, такую как id, мы хотим, чтобы тип A мог лежать в любой вселенной
-- Поэтому все функции (и остальные определения) полиморфны по уровню вселенной, в которой они лежат
\func id' (A : \Type) (a : A) => a

-- Еще несколько примеров:
\func test1_ => id \lp Nat 0
\func test2_ => id (\suc \lp) \Type0 Nat
\func test3 => id (\suc (\suc \lp)) (\Type0 -> \Type1) (\lam X => X)
\func test4 => id (\suc \lp) _ id
\func test4' => id (\suc \lp) (\Pi (A : \Type \lp) -> A -> A) (id \lp)

-- При обращении к определению можно явно указать его уровень, то есть чему будет равен параметр \lp:
\func test5 => id (\Type \lp) Nat
-- Либо так:
\func test5' => id \levels (\suc \lp) _ (\Type \lp) Nat
-- Второй вариант синтаксиса полезен когда уровень является константой:
\func test6 => id \levels 2 _ \Type1 \Type0
\func test6' => id \levels 0 _ Nat 1
-- Если при обращению к определению уровень не указан явно, он будет выведен автоматически, как и в случае с \Type
-- В большинстве случаев нет необходимости указывать уровень явно

-- Параметры \data не влияют на его уровень
\data Magma' (A : \Type0) : \Type0
  | con (A -> A -> A)

\func test7 : \Type \lp => Magma' Nat

-- С помощью \plevels можно принимать именованные параметры-уровни:
\func id__ \plevels p1 >= p2 >= p3 (A : \Type (\max p1 p2)) (a : A) => a

-- 2. Предикаты

-- Есть несколько способов определять предикаты над некоторым типом A:
-- * Выразить из через уже существующие (например равенство) и различные логические связки.
--   Например, предикат isEven можно выразить как \lam n => \Sigma (k : Nat) (n = 2 * k)
-- * Рекурсивно. Этот способ работает только если A -- тип данных
-- * Индуктивно

-- Определение <= через равенство
\func lessOrEq (n m : Nat) => \Sigma (k : Nat) (n Nat.+ k = m)

-- \func lessOrEq_int (n m : Int) => \Sigma (k : Nat) (m = n + k)

-- Рекурсивное определение предиката <=
\func lessOrEq' (n m : Nat) : \Type
  | 0, m => \Sigma
  | suc n, 0 => Empty
  | suc n, suc m => lessOrEq' n m

{-

---------- (zero<=_)
  0 <= m


    n <= m
-------------- (suc<=suc)
suc n <= suc m

 -}

-- Первое индуктивное определение <=
\data LessOrEq (n m : Nat) \with
  | 0, m => zero<=_
  | suc n, suc m => suc<=suc (LessOrEq n m)

\func test11 : LessOrEq 0 100 => zero<=_
\func test12 : LessOrEq 3 67 => suc<=suc (suc<=suc (suc<=suc zero<=_))
-- \func test10 : LessOrEq 1 0 => {?}
\func test10 : Not (LessOrEq 1 0) => \case __

-- Один и тот же предикат можно определить индуктивно различными способами
-- Когда мы хотим задать предикат индуктивно, нам нужно просто написать набор правил,
-- которые верны для данного предиката и при этом пораждают его
-- Например, в LessOrEq у нас два правила:
-- * 0 <= m для любого m
-- * если n <= m, то suc n <= suc m
-- Любое неравенство можно получить из этих двух правил

-- Но это не единственный набор правил, который порождает <=
-- Например, мы можем взять следующий набор:
-- * n <= n для всех n
-- * если n <= m, то n <= suc m
-- Этот набор реализован в LessOrEq''

{-

  n = m
---------- (<=-refl)
  n <= m

 n <= m
---------- (<=-step)
n <= suc m

 -}

-- Второе индуктивное определение <=
\data LessOrEq' (n m : Nat) \elim m
  | m => <=-refl (n = m)
  | suc m => <=-step (LessOrEq' n m)

\func test11' : LessOrEq' 0 1 => <=-step (<=-refl idp)

-- 3. Разрешимые предикаты

-- Предикат -- это функция вида P : A -> \Type
-- Предикат называется разрешимым, если существует алгоритм, разрешающий его,
-- то есть, по a : A, возвращающий true, если P a верно, и false, если ложно

-- Так как у нас логика интуиционистская, то не все предикаты разрешимы
-- На самом деле, исключенное третье эквивалентно утверждению о том, что все предикаты разрешимы

-- Пример неразрешимого предиката, который мы запишем неформально,
-- так как его формальное описание будет довольно длинным:
-- P : Nat -> \Type
-- P n = "останавливается ли машина Тьюринга с номером n на входе n"
--
-- Мы не можем ни доказать, что P разрешим, ни опровергнуть это,
-- так как мы не предполагаем ни исключенное третье, ни его отрицание
--
-- Более простой пример неразрешимого предиката -- это предикат равенства двух функций типа Nat -> Nat

-- Мы можем определить предикат разрешимости на предикатах
\data Decide (A : \Type)
  | yes A
  | no (A -> Empty)

-- DecPred P верно в тогда и только тогда, когда P разрешим
\func DecPred {A : \Type} (P : A -> \Type) => \Pi (a : A) -> Decide (P a)

-- Например, предикат \lam n => n = 0 разрешим
\func decide0 : DecPred (\lam (n : Nat) => n = 0) => aux
\where {
  \func aux (n : Nat) : Decide (n = 0)
    | 0 => yes idp
    | suc n => no \case __
}

-- 4. Разрешимое равенство

-- Мы можем определить класс типов, являющийся аналогом Eq в Haskell,
-- но в котором вместо функции == : A -> A -> Bool будет хранится доказательство, что равенство разрешимо
-- Это лучше, так как в Haskell в качестве == мы можем написать вообще произвольную функцию,
-- даже такую, которая не имеет никакого смысла
-- А при таком определении Eq функция равенства всегда будет определена корректно:
\class Eq (A : \Type) {
  | decideEq (a a' : A) : Decide (a = a')

  \func \infix 4 == (a a' : A) : Bool => \case decideEq a a' \with {
    | yes a1 => true
    | no _x => false
  }
}

-- Докажем, что равенство натуральных чисел разрешимо
\instance NatEq : Eq Nat
  | decideEq (x y : Nat) : Decide (x = y) \with {
    | 0, 0 => yes idp
    | 0, suc y => no \case __
    | suc x, 0 => no \case __
    | suc x, suc y => \case decideEq x y \with {
      | yes p => yes (pmap suc p)
      | no n => no \lam p => n (pmap pred p)
    }
  }

\func pred (n : Nat) : Nat
  | 0 => 0
  | suc n => n

\open Eq(==)

\func test1 : (0 == 0) = true => idp
\func test2 : (0 == 1) = false => idp

-- DecEq A верно в точности тогда, когда предикат равенства на A разрешим
\func DecEq (A : \Type) => \Pi (a a' : A) -> Decide (a = a')

-- 5. Предикаты A -> Bool

-- Разрешимые предикаты вида A -> \Type в точности соответствуют функциям вида A -> Bool

\func So-dec {b : Bool} : Decide (So b) \elim b
  | false => no \lam e => e
  | true => yes ()

-- Легко построить функции из A -> Bool в тип разрешимых предикатов и наоборот
-- Эти функции почти взаимно обратны. Это будет верно, если правильно сформулировать это утверждение

\func FromBoolToDec {A : \Type} (p : A -> Bool) : \Sigma (P : A -> \Type) (DecPred P)
  => (\lam a => So (p a), \lam a => So-dec)

\func FromDecToBool {A : \Type} (P : \Sigma (P : A -> \Type) (DecPred P)) : A -> Bool
  => \lam a => \case P.2 a \with {
    | yes _ => true
    | no _ => false
  }

-- 6. Индукция-рекурсия

-- Рекурсия-рекурсия -- это принцип, позволяющий определять взаимно рекурсивные функции
-- Пример: функции isEven и isOdd
\func isEven (n : Nat) : Bool
  | 0 => true
  | suc n => isOdd n

\func isOdd (n : Nat) : Bool
  | 0 => false
  | suc n => isEven n

-- Индукция-индукция -- это принцип, позволяющий определять взаимно рекурсивные типы данных
-- Когда мы определяем взаимно рекурсивный тип данных, нужно явно указывать его тип
-- Пример: типы IsEven и IsOdd
\data IsEven (n : Nat) : \Type \with
  | 0 => zero-even
  | suc n => suc-even (IsOdd n)

\data IsOdd (n : Nat) : \Type \with
  | suc n => suc-odd (IsEven n)

-- Индукция-рекурсия -- это принцип, позволяющий определять тип данных, взаимно рекурсивный с функцией
-- Мы можем определить свою вселенную, состоящую только из определенного набора типов, при помощи этого принципа

\data Type
  | nat
  | list Type
  | arr Type Type
  \where {
    \use \coerce foobar (t : Type) => El t
  }

-- Мы должны еще определить функцию, которая переводит элементы Type в настоящие типы
\func El (t : Type) : \Set
  | nat => Nat
  | list t => List (El t)
  | arr t1 t2 => El t1 -> El t2

\func idc {T : Type} (x : T) : T => x

-- Если мы хотим определить вселенную, в которой у нас есть зависимые типы,
-- то такое определение должно быть индуктивно-рекурсивным
\data Type' : \Set
  | nat'
  | list' Type'
  | pi (A : Type') (El' A -> Type')

\func El' (t : Type') : \Set
  | nat' => Nat
  | list' t => List (El' t)
  | pi A B => \Pi (a : El' A) -> El' (B a)

-- 7. \case в языках с зависимыми типами является более сложной конструкцией в общем случае, чем в языках без них

-- foo лучше доказать, просто обобщив утверждение, но мы докажем ее через \case,
-- чтобы продемонстировать возможности этой конструкции
\func foo {A : \Type} (p : A -> Bool) (a : A) : p a = not (not (p a)) =>
  -- 1. Перед \with мы можем написать \return <expr>, где <expr> -- это тип, который возвращается из \case
  -- 2. После выражения, на котором мы паттерн матчимся, можно написать \as b,
  --    где b -- это переменная, которая будет связана в этой конструкции
  --    Эту переменную можно использовать в выражении, которое идет после \return
  -- 3. Идея в том, что возвращаемый тип может зависеть от выражения, на котором мы паттерн матчимся
  --    Эту конструкцию можно использовать, чтобы эту зависимость явно указать
  -- 4. В каждом отдельном случае нам нужно будет вернуть указанный после \return тип,
  --    в котором b заменено на соответствующий паттерн
  \case p a \as b \return b = not (not b) \with {
    | true => idp -- Например, здесь нужно вернуть значение типа true = not (not true)
    | false => idp -- А здесь мы возвращаем значение типа false = not (not false)
  }

-- foo можно переписать через helper
\func foo' {A : \Type} (p : A -> Bool) (a : A) : p a = not (not (p a)) => aux (p a)
  \where {
    \func aux (b : Bool) : b = not (not b)
      | true => idp
      | false => idp
  }

-- 8. Пример доказательств через \case

-- Вспомогательное утверждение
\func <=-helper {x y : Nat} (p : LessOrEq x y) : LessOrEq x (suc y) \elim x, y, p
  | 0, y, _ => zero<=_
  | suc x, suc y, suc<=suc p => suc<=suc (<=-helper p)

\func filter {A : \Type} (p : A -> Bool) (xs : List A) : List A \elim xs
  | nil => nil
  | x :: xs => \case p x \with {
    | true => x :: filter p xs
    | false => filter p xs
  }

-- Докажем, что длина отфильтрованного списка не превышает длины исходного
\func filter-lem {A : \Type} (p : A -> Bool) (xs : List A)
  : LessOrEq (length (filter p xs)) (length xs) \elim xs
  | nil => zero<=_
  | x :: xs => \case
    p x \as b
  \return LessOrEq (length (\case b \with {
    | true => x :: filter p xs
    | false => filter p xs
  })) (suc (length xs))
  \with {
    | true => suc<=suc (filter-lem p xs)
    | false => <=-helper (filter-lem p xs)
  }

-- 9. cases и mcases

-- Мета cases принимает в качестве первого аргумента список разбираемых выражений (как \case, только в скобках)
-- Отличие в том, что она пытается заменить эти выражения в контексте и возвращаемом значении
-- Второй аргумент это либо \with { ... }, как в \case, либо общее выражение для всех веток,
-- либо разделённое через <|> -- это такая мета, которая пытается по очереди подставить выражения слева и справа
\func filter-lem' {A : \Type} (p : A -> Bool) (xs : List A)
  : LessOrEq (length (filter p xs)) (length xs) \elim xs
  | nil => zero<=_
  | x :: xs => cases (p x) (suc<=suc (filter-lem p xs) <|> <=-helper (filter-lem p xs))

-- Мета mcases это продвинутый cases, она сама пытается найти вхождения \case в возвращаемом значении
-- и делает cases по разбираемым выражениям
\func filter-lem'' {A : \Type} (p : A -> Bool) (xs : List A)
  : LessOrEq (length (filter p xs)) (length xs) \elim xs
  | nil => zero<=_
  | x :: xs => mcases (suc<=suc (filter-lem p xs) <|> <=-helper (filter-lem p xs))

-- 10. \case на idp

-- Когда мы паттерн матчимся на некотором значении e, связь этого выражения с резльтатом паттерн матчинга теряется
-- Например, в выражении \case e \with { | pat => expr } в expr мы даже не сможем доказать, что e равно pat
-- Иногда бывает необходимо запоминать эту связь
-- Для этого можно использовать следующий трюк
-- Мы в \case кроме самого выражения еще паттерн-матчимся на idp,
-- но указываем ему тип, который зависит от первого значения
-- Тогда в каждом случае q будем доказательством равенства между исходным значением и паттерном
\func baz {A : \Type} (p : A -> Bool) (a : A) : p a = not (not (p a)) =>
  -- Мы можем явно указывать не только тип возвращаемого значения, но и типы выражений, на которых мы паттерн-матчимся
  -- И в них также можно использовать переменные, связанные в \as
  \case p a \as b, idp : p a = b \with {
    | true, q => rewrite q idp -- Здесь q : false = p a
    | false, q => rewrite q idp -- Здесь q : true = p a
  }

-- То же самое через хелпер:
\func baz'' {A : \Type} (p : A -> Bool) (a : A) : p a = not (not (p a))
  => aux {A} {p} {a} (p a) idp
  \where {
    \func aux {A : \Type} {p : A -> Bool} {a : A} (b : Bool) (q : p a = b) : p a = not (not (p a)) \elim b
      | false => rewrite q idp -- Здесь q : true = p a
      | true => rewrite q idp -- Здесь q : false = p a
  }

-- В мете cases можно указать "arg addPath" после выражения,
-- чтобы добавить значение типа равенства с исходным выражением
\func baz' {A : \Type} (p : A -> Bool) (a : A) : p a = not (not (p a))
  => cases (p a arg addPath) \with {
    | false, p1 => idp
    | true, p1 => idp
  }

-- 11. Еще один пример

\func BoolFuncLem (f : Bool -> Bool) (x : Bool) : f (f (f x)) = f x => cases (f false arg addPath, f true, x) \with {
  | false, p, false, false => rewrite (p, p) p
  | false, p, false, true => {?}
  | false, p, true, false => {?}
  | false, p, true, true => {?}
  | true, p, false, false => {?}
  | true, p, false, true => {?}
  | true, p, true, false => {?}
  | true, p, true, true => {?}
}

-- 12. Матчинг с idp в \case

-- Мы не можем сматчить p по idp, потому что паттерн-матчинг по idp работает только
-- когда мы одновременно матчим равенство с одной из его сторон
-- \func case_idp {A : \Type} {x y : A} (p : x = y) : idp *> p = p => \case p \with { idp => {?} }

-- Но также мы не можем и сматчить их вместе, потому что для \case наша переменная это просто выражение...
-- \func case_idp {A : \Type} {x y : A} (p : x = y) : idp *> p = p => \case y, p \with { y, idp => {?} }

-- Нам на помощь приходит \elim, который говорит \case, что мы хотим удалить переменную из контекста
-- и заменить её в результирующем типе на текущее значение
-- Нужно только элиминировать одновременно y и p, потому что элиминировать y без p нельзя
\func case_idp {A : \Type} {x y : A} (p : x = y) : idp *> p = p
  => \case \elim y, \elim p \with { y, idp => idp }

-- Без \elim:
\func case_idp' {A : \Type} {x y : A} (p : x = y) : idp *> p = p
  => \case y \as y', p \as p' : x = y' \return idp *> p' = p' \with { y, idp => idp }
